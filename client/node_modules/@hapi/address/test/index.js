'use strict';

const Punycode = require('punycode');

const Code = require('@hapi/code');
const Address = require('..');
const Lab = require('@hapi/lab');


const internals = {};


const { describe, it } = exports.lab = Lab.script();
const expect = Code.expect;


describe('email', () => {

    it('available as direct require', () => {

        expect(require('../lib/email').isValid('test@example.com')).to.be.true();
    });

    describe('analyze()', () => {

        it('identifies error', () => {

            const tests = [
                ['', 'Address must be a non-empty string'],
                ['êjness@iana.org', 'Address contains forbidden Unicode characters', { allowUnicode: false }],
                ['test@test@test', 'Address cannot contain more than one @ character'],
                ['test', 'Address must contain one @ character'],
                ['@example.com', 'Address local part cannot be empty'],
                ['test@', 'Domain must be a non-empty string'],
                ['1234567890@abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz.com', 'Address too long'],
                ['1234567890123456789012345678901234567890123456789012345678901234567890@example.com', 'Address local part too long'],
                ['x..y@example.com', 'Address local part contains empty dot-separated segment'],
                ['x:y@example.com', 'Address local part contains invalid character'],
                ['ê:y@example.com', 'Address local part contains invalid character'],
                ['test@com', 'Domain lacks the minimum required number of segments'],
                ['test@x.no-such-tld', 'Domain uses forbidden TLD'],
                ['test@example..com', 'Domain contains empty dot-separated segment'],
                ['test@1234567890123456789012345678901234567890123456789012345678901234567890.com', 'Domain contains dot-separated segment that is too long'],
                ['test@example+.com', 'Domain contains invalid character', { tlds: false }],
                ['test@example.com_', 'Domain contains invalid tld character', { tlds: false }]
            ];

            for (let i = 0; i < tests.length; ++i) {
                const email = tests[i];
                const output = Address.email.analyze(email[0], email[2]);
                const result = email[1];

                if (!output ||
                    output.error !== result) {

                    console.log(i, email[0]);
                }

                expect(output.error).to.equal(result);
            }
        });

        it('validates options', () => {

            const tests = [
                ['test@example.com', 'Invalid options: tlds must be a boolean or an object', { tlds: 1 }],
                ['test@example.com', 'Invalid options: tlds.allow must be a Set object or true', { tlds: { allow: ['test'] } }],
                ['test@example.com', 'Invalid options: tlds.deny must be a Set object', { tlds: { deny: ['test'] } }],
                ['test@example.com', 'Invalid options: cannot specify both tlds.allow and tlds.deny lists', { tlds: { allow: new Set(), deny: new Set() } }],
                [1, 'Invalid input: email must be a string']
            ];

            for (let i = 0; i < tests.length; ++i) {
                const email = tests[i];
                expect(() => Address.email.analyze(email[0], email[2])).to.throw(email[1]);
            }
        });

        describe('validated TLD', () => {

            it('applies built-in list', () => {

                expect(Address.email.analyze('test@example.com')).to.not.exist();
                expect(Address.email.analyze('test@example.com', { tlds: true })).to.not.exist();
                expect(Address.email.analyze('test@example.com', { tlds: { allow: true } })).to.not.exist();
            });

            it('ignores built-in list', () => {

                expect