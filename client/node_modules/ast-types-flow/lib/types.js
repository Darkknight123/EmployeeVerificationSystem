/**
 * @flow
 */

'use strict';

/*
 * Flow types for the Babylon AST.
 */

// Abstract types. Something must extend these.

export type Comment = {
  type: 'CommentLine';
  _CommentLine: void;
  value: string;
  end: number;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
} | {
  type: 'CommentBlock';
  _CommentBlock: void;
  value: string;
  end: number;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
};

export type Declaration = {
  type: 'ClassBody';
  _ClassBody: void;
  body: Array<Node>;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'ClassDeclaration';
  _ClassDeclaration: void;
  body: ClassBody;
  id: ?Identifier;
  superClass: ?Expression;
  decorators: any;
  superTypeParameters: any;
  typeParameters: any;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'FunctionDeclaration';
  _FunctionDeclaration: void;
  body: BlockStatement;
  id: Identifier;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
  async: boolean;
  defaults: Array<?Expression>;
  expression: boolean;
  generator: boolean;
  params: Array<Pattern>;
  rest: ?Identifier;
  returnType: ?TypeAnnotation;
  typeParameters: ?TypeParameterDeclaration;
} | {
  type: 'MethodDefinition';
  _MethodDefinition: void;
  computed: boolean;
  key: Node;
  kind: 'constructor' | 'method' | 'get' | 'set';
  static: boolean;
  value: FunctionExpression;
  decorators: ?Array<Decorator>;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'VariableDeclaration';
  _VariableDeclaration: void;
  declarations: Array<VariableDeclarator>;
  kind: 'var' | 'let' | 'const';
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'ClassProperty';
  _ClassProperty: void;
  computed: boolean;
  key: Node;
  static: boolean;
  typeAnnotation: ?TypeAnnotation;
  value: ?Expression;
  decorators: Array<Decorator>;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
};

export type Expression = {
  type: 'ArrayExpression';
  _ArrayExpression: void;
  elements: Array<?Node>;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'AssignmentExpression';
  _AssignmentExpression: void;
  left: Pattern;
  operator: AssignmentOperator;
  right: Expression;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'AwaitExpression';
  _AwaitExpression: void;
  all: boolean;
  argument: ?Expression;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'BinaryExpression';
  _BinaryExpression: void;
  left: Expression;
  operator: BinaryOperator;
  right: Expression;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'BindExpression';
  _BindExpression: void;
  callee: Node;
  object: Node;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'CallExpression';
  _CallExpression: void;
  arguments: Array<Node>;
  callee: Expression;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'ClassExpression';
  _ClassExpression: void;
  body: ClassBody;
  id: ?Identifier;
  superClass: ?Expression;
  decorators: any;
  superTypeParameters: any;
  typeParameters: any;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'ComprehensionExpression';
  _ComprehensionExpression: void;
  body: Expression;
  blocks: Array<ComprehensionBlock>;
  filter: ?Expression;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'ConditionalExpression';
  _ConditionalExpression: void;
  alternate: Expression;
  consequent: Expression;
  test: Expression;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    start: {column: number, line: number},
  };
  start: number;
  trailingComments: ?Array<Comment>;
} | {
  type: 'DoExpression';
  _DoExpression: void;
  body: Statement;
  end: number;
  innerComments: ?Array<Comment>;
  leadingComments: ?Array<Comment>;
  loc: {
    end: {column: number, line: number},
    st